# Applicative and Normal Order

There are two ways that Scheme's combinations and its sub-expressions
get evaluated in terms of order of evaluation process
on the expressions and their reductions.

TL;DR:

- **Applicative Order** -- It is an order that
  evaluates sub-expressions and reduces them to an
  evaluated value as the parser passes each
  sub-expression within a combination.
- **Normal Order** -- It is an order where you expand
  procedure definitions within combinations to
  primitive procedure operations via evaluation process
  and then reduce the expanded combination (i.e. whole
  expression) to its calculated value.

To provide a demonstration for each order, the
following procedures will be defined:
```scheme
(define (square x)
        (* x x))
(define (sum-squares x)
        (+ (square x) (square x)))
```
Imagine that you would perform evaluation of
`(sum-squares 2)`.
The applicative order would do the following:
1. the parser would look at `sum-squares`
   sub-expression that is a reference to a named
   procedure.
2. The parser would pull official definition of it and
   replace its formal parameters (i.e. `x`) with actual
   arguments (i.e. `2`).
3. The parser would replace


The normal order would perform the following evaluation
of `(sum-squares 2)`:
1. The parser would look at defined procedure of
   `sum-squares` and pull its definition. Thus
   expanding the evaluation to `(+ (square x) (square x)`.
2. The parser would look `square` procedure and pull
   its definition and then expanding the preceding
   combination with `(+ (* x x) (* x x))`.
3. Since the combination has its operators been
   expanded to its primitive ones, the parser will
   replace `x` formal paramter with the argument of
   `2`.
4. Evaluate the combination by starting evaluation at
   deeper levels (i.e. `(* x x)`) and going upwards.

A disadvantage of normal order is that the process of
expanding the defined procedures will duplicate amount
of combinations to evalute and it will increase usage
of memory as a result unlike the applicative order that
parses a combination recursively such that
higher-level combinations just get evaluted to
expressions and decreasing the memory usage during
evaluation.
